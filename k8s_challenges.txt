üü¢ 1Ô∏è‚É£ Pod Basics (Very Easy)

Focus: Pods, containers

Goal:
Run a single Pod with your Go container
Verify it starts successfully

Hints:

kind: Pod
containerPort
kubectl logs

kubectl apply -f go-pod.yaml
kubectl get pods
kubectl logs go-pod
kubectl delete pod go-pod
kubectl get pods



üü¢ 2Ô∏è‚É£ Deploymenüü¢ 1Ô∏è‚É£ Pod Basics (Very Easy)

Focus: Pods, containers

Goal:

Run a single Pod with your Go container

Verify it starts successfully

Hints:

kind: Pod

containerPort

kubectl logs

üü¢ 2Ô∏è‚É£ Deployment Fundamentals (Easy)

Focus: Deployments, replicas

Goal:

Convert your Pod into a Deployment

Run 2 replicas

Hints:
replicas
matchLabels

Delete a pod manually and observe behavior


kubectl apply -f go-deployment-two.yaml
kubectl get pods
kubectl delete pod go-deployment-two-6c6b986878-fcpm6
kubectl get pods




üü¢ 3Ô∏è‚É£ Self-Healing Behavior (Easy)

Focus: Controllers

Goal:

Kill a pod
Watch Kubernetes recreate it automatically

Hints:

kubectl delete pod
kubectl get pods -w


kubectl delete pod go-deployment-two-6c6b986878-fmzv2  
kubectl get pods -w


üü¢ 4Ô∏è‚É£ Resource Requests & Limits (Easy‚ÄìMedium)

Focus: Resource management

Goal:

Add CPU & memory requests and limits
Verify they appear in pod description

Hints:

resources.requests
resources.limits

kubectl describe pod

resources:
    requests:
        memory: "128Mi"
        cpu: "256m"
    limits:
        memory: "128Mi"
        cpu: "500m"

kubectl describe go-deployment-two-6c6b986878-tfpmr

Containers:
  my-go-app:
    Container ID:   docker://4cfb2f7af9461f0ebee4ade1075e75cf18d5aa804a2c6c7b861addfdcd72ab14
    Image:          my-go-projects:latest
    Image ID:       docker://sha256:ebed48ac76abfb19b5b4cafb4324bb05225ebd2b356c0dcffb5e6bc600fe0958
    Port:           8080/TCP
    Host Port:      0/TCP
    State:          Waiting
      Reason:       CrashLoopBackOff
    Last State:     Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Thu, 15 Jan 2026 21:32:04 +0800
      Finished:     Thu, 15 Jan 2026 21:32:04 +0800
    Ready:          False
    Restart Count:  7
    Limits:
      cpu:     500m
      memory:  128Mi
    Requests:
      cpu:        256m
      memory:     128Mi
    Environment:  <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-9nn6t (ro)


üü° 5Ô∏è‚É£ Expose with a Service (Medium)

Focus: Networking basics

Goal:

Expose your Deployment internally
Access it locally

Hints:

Service
ClusterIP
Label selectors

kubectl expose deployment nginx-deployment \
--type=ClusterIP \
--name=nginx-service \
--port=80 \
--target-port=80
kubectl get svc
kubectl describe svc nginx-service

üü° 6Ô∏è‚É£ NodePort Access (Medium)

Focus: External access

Goal:

Make your app reachable from your browser

Hints:

NodePort

kubectl get svc

localhost:<nodePort>

kubectl get svc 
curl http://localhost:30080



üü° 7Ô∏è‚É£ ConfigMap via Environment Variables (Medium)

Focus: Configuration

Goal:

Inject configuration into nginx or phpMyAdmin

Read it at runtime (e.g., server_name for nginx, database credentials for phpMyAdmin)

Hints:

Create a ConfigMap with key-value pairs

Use envFrom in your Deployment YAML

Restart pods to see changes take effect

Example variables:

NGINX_HOST

PMA_HOST

in spec.template.spec.containers.envFrom

envFrom: 
    - configMapRef:
        name: nginx-configmap
    - secretRef:
        name: nginx-secret

kubectl apply -f nginx-secret.yaml
kubectl apply -f nginx-configmap.yaml
kubectl get pods 
kubectl get svc
kubectl get serets 
kubectl get configmaps 


üü° 8Ô∏è‚É£ ConfigMap as a File (Medium‚ÄìHard)

Focus: Volume mounts

Goal:

Mount a configuration file into nginx (nginx.conf) or phpMyAdmin (config.inc.php)

Observe the container reading it from disk

Hints:

volumes + volumeMounts

Use kubectl exec <pod> -- cat /path/to/config

kubectl exec nginx-deployment-8568495446-vkrfl -- cat /etc/nginx/nginx.conf
volumeMounts:
    - name: nginx-config-volume
        mountPath: /etc/nginx/nginx.conf
        subPath: nginx.conf

volumes:
        - name: nginx-config-volume
          configMap:
            name: nginx-configmap
            items:
              - key: nginx.conf
                path: nginx.conf

kubectl apply -f nginx-deployment.yaml
kubectl describe pod nginx-deployment-fb8f8d6cc-8ldc6





Modify ConfigMap ‚Üí kubectl rollout restart to update pods

üü† 9Ô∏è‚É£ Secrets (Medium‚ÄìHard)

Focus: Secure configuration

Goal:
Store sensitive data for MySQL (password, root password)
Inject securely into mysql or phpMyAdmin pods

Hints:

kind: Secret
Base64 encode your values
Consume via:
env: for mysql password
Mounted file for phpMyAdmin config

apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  password: emFtYm9hbmdhMDQ3
  root-password: emFtYm9hbmdhMDQ3

kubectl apply -f mysql-secret.yaml

mysql-deployment.yaml

env: 
  - name: MYSQL_PASSWORD
    valueFrom:
      secretKeyRef:
        name: mysql-secret
        key: MYSQL_PASSWORD
  - name: MYSQL_ROOT_PASSWORD
    valueFrom:
      secretKeyRef:
        name: mysql-secret
        key: MYSQL_ROOT_PASSWORD

kubectl apply -f mysql-deployment.yaml
kubectl describe secret mysql-secret


üü† 1Ô∏è‚É£0Ô∏è‚É£ Health Probes (Hard)

Focus: Reliability

Goal:

Add liveness & readiness probes for nginx or mysql
Observe pod restarts or traffic blocking

Hints:

Nginx: / with httpGet probe
MySQL: TCP port 3306 probe
Use livenessProbe + readinessProbe fields

livenessProbe: 
  tcpSocket: 
    port: 3306
  initialDelaySeconds: 30
  periodSeconds: 10
readinessProbe:
  tcpSocket: 
    port: 3306
  initialDelaySeconds: 10
  periodSeconds: 5
kubectl apply -f mysql-deployment.yaml


üü† 1Ô∏è‚É£1Ô∏è‚É£ Rolling Updates (Hard)

Focus: Zero downtime

Goal:

Deploy a new version of nginx, MySQL, or phpMyAdmin
Observe rolling update behavior

Hints:

strategy: RollingUpdate
maxUnavailable / maxSurge
kubectl rollout status deployment <name>

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 2
    maxSurge: 1

kubectl rollout restart deployment mysql-deployment
kubectl rollout status deployment mysql-deployment

mar@PajiiMarr-M3 ~/go_projects/composite_types/maps kubectl rollout restart deployment mysql-deployment
deployment.apps/mysql-deployment restarted
mar@PajiiMarr-M3 ~/go_projects/composite_types/maps kubectl rollout status deployment mysql-deployment
Waiting for deployment "mysql-deployment" rollout to finish: 1 out of 2 new replicas have been updated...
Waiting for deployment "mysql-deployment" rollout to finish: 1 out of 2 new replicas have been updated...
Waiting for deployment "mysql-deployment" rollout to finish: 1 out of 2 new replicas have been updated...
Waiting for deployment "mysql-deployment" rollout to finish: 1 old replicas are pending termination...
Waiting for deployment "mysql-deployment" rollout to finish: 1 old replicas are pending termination...
deployment "mysql-deployment" successfully rolled out
mar@PajiiMarr-M3 ~/go_projects/composite_types/maps 

üî¥ 1Ô∏è‚É£2Ô∏è‚É£ Persistent Storage (Hard)

Focus: Stateful workloads

Goal:

Persist MySQL data across pod restarts

Ensure phpMyAdmin can still connect

Hints:

Use PersistentVolumeClaim + volumeMounts

Delete pod ‚Üí data persists

Optionally test with emptyDir (temporary) first

üî¥ 1Ô∏è‚É£3Ô∏è‚É£ Scaling Under Load (Very Hard)

Focus: Capacity & scaling

Goal:

Scale nginx or phpMyAdmin replicas

Observe CPU/memory usage and network behavior

Hints:

kubectl scale deployment <name> --replicas=N

kubectl top pods

Set resource requests/limits for realistic scaling

üî¥ 1Ô∏è‚É£4Ô∏è‚É£ Full App Lifecycle (Expert)

Focus: Integration of everything

Goal:

Run a full stack:

Deployment: MySQL + phpMyAdmin + optional nginx front

Services for each

ConfigMaps + Secrets

Resource limits

Liveness/readiness probes

Rolling updates

Observe pod failures & recovery

Hints:

Label consistency across Deployments/Services

Minimal YAML duplication (reuse ConfigMaps/Secrets)

Delete a pod ‚Üí ensure recovery and data persistence